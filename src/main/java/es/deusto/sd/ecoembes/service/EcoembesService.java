/**
 * This code is based on solutions provided by ChatGPT 4o and 
 * adapted using GitHub Copilot. It has been thoroughly reviewed 
 * and validated to ensure correctness and that it is free of errors.
 */
package es.deusto.sd.ecoembes.service;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import es.deusto.sd.ecoembes.dao.AssignmentRepository;
import es.deusto.sd.ecoembes.dao.DumpsterRepository;
import es.deusto.sd.ecoembes.dao.DumpsterUsageRecordRepository;
import es.deusto.sd.ecoembes.dao.EmployeeRepository;
import es.deusto.sd.ecoembes.dao.RecyclingPlantRepository;
import es.deusto.sd.ecoembes.entity.Assignment;
import es.deusto.sd.ecoembes.entity.Dumpster;
import es.deusto.sd.ecoembes.entity.DumpsterUsageRecord;
import es.deusto.sd.ecoembes.entity.Employee;
import es.deusto.sd.ecoembes.entity.FillLevel;
import es.deusto.sd.ecoembes.entity.RecyclingPlant;

@Service
public class EcoembesService {

	private final DumpsterRepository dumpsterRepository;
	private final RecyclingPlantRepository plantRepository;
	private final EmployeeRepository employeeRepository;
	private final AssignmentRepository assignmentRepository;
	private final DumpsterUsageRecordRepository usageRecordRepository; // No se usa ahora mismo, pero podria ser util luego

	public EcoembesService(DumpsterRepository dumpsterRepository,
						   RecyclingPlantRepository plantRepository,
						   EmployeeRepository employeeRepository,
						   AssignmentRepository assignmentRepository,
						   DumpsterUsageRecordRepository usageRecordRepository) {
		this.dumpsterRepository = dumpsterRepository;
		this.plantRepository = plantRepository;
		this.employeeRepository = employeeRepository;
		this.assignmentRepository = assignmentRepository;
		this.usageRecordRepository = usageRecordRepository;
	}

	// -------------------------- Service methods (work only with entities) --------------------------

	/**
	 * Updates the status of a dumpster with sensor data
	 */
	public void updateDumpsterInfo(Long dumpsterId, int estimatedContainers, FillLevel fillLevel) {
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Dumpster ID cannot be null");
		}
		if (estimatedContainers < 0) {
			throw new IllegalArgumentException("Estimated containers cannot be negative");
		}
		if (fillLevel == null) {
			throw new IllegalArgumentException("Fill level cannot be null");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found");
		}

		dumpster.get().updateStatus(estimatedContainers, fillLevel);
		dumpsterRepository.save(dumpster.get());
	}

	/**
	 * Creates a new dumpster
	 */
	public Dumpster createDumpster(String location, String postalCode, double initialCapacity) {
		if (location == null || location.isBlank()) {
			throw new IllegalArgumentException("Location cannot be null or empty");
		}
		if (postalCode == null || postalCode.isBlank()) {
			throw new IllegalArgumentException("Postal code cannot be null or empty");
		}
		if (initialCapacity <= 0) {
			throw new IllegalArgumentException("Initial capacity must be greater than zero");
		}

		Dumpster d = new Dumpster(location, postalCode, initialCapacity);
		// ID will be auto-generated by JPA
		return dumpsterRepository.save(d);
	}

	/**
	 * Gets usage history for a dumpster within a date range
	 */
	public List<DumpsterUsageRecord> getDumpsterUsage(Long dumpsterId, LocalDate startDate, LocalDate endDate) {
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Invalid dumpster ID");
		}
		if (startDate == null || endDate == null) {
			throw new IllegalArgumentException("Start date and end date cannot be null");
		}
		if (startDate.isAfter(endDate)) {
			throw new IllegalArgumentException("Start date must be before or equal to end date");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found");
		}

		return dumpster.get().getUsageHistory().stream()
				.filter(r -> !(r.getDate().isBefore(startDate) || r.getDate().isAfter(endDate)))
				.collect(Collectors.toList());
	}

	/**
	 * Gets all dumpsters in a specific postal code area with their status on a given date
	 */
	public List<Dumpster> getDumpstersByArea(String postalCode) {
		if (postalCode == null || postalCode.isBlank()) {
			throw new IllegalArgumentException("Postal code cannot be null or empty");
		}

		return dumpsterRepository.findByPostalCode(postalCode);
	}

	/**
	 * Gets the fill level for a dumpster on a specific date
	 */
	public FillLevel getDumpsterFillLevelOnDate(Dumpster dumpster, LocalDate date) {
		if (dumpster == null) {
			throw new IllegalArgumentException("Dumpster cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}

		DumpsterUsageRecord match = dumpster.getUsageHistory().stream()
				.filter(r -> r.getDate().equals(date))
				.findFirst().orElse(null);

		return (match != null) ? match.getFillLevel() : dumpster.getFillLevel();
	}

	/**
	 * Gets all recycling plants
	 */
	public List<RecyclingPlant> getAllPlants() {
		return plantRepository.findAll();
	}

	/**
	 * Gets a single recycling plant by ID
	 */
	public RecyclingPlant getPlantById(Long plantId) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}
		return plant.get();
	}

	/**
	 * Gets all dumpsters assigned to a plant on a specific date
	 */
	public List<Dumpster> getAssignedDumpsters(Long plantId, LocalDate date) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}

		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}

		return assignmentRepository.findAll().stream()
				.filter(a -> a.getPlant().getId().equals(plantId) && a.getDate().equals(date))
				.map(Assignment::getDumpster)
				.filter(d -> d != null)
				.collect(Collectors.toList());
	}

	/**
	 * Calculates available capacity for a plant on a given date
	 */
	public double calculatePlantCapacity(Long plantId, LocalDate date) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}

		List<Dumpster> assignedDumpsters = getAssignedDumpsters(plantId, date);

		double totalCapacityTons = 0.0;
		double occupiedTons = 0.0;

		for (Dumpster d : assignedDumpsters) {
			if (d == null) {
				continue;
			}
			
			double capacityKg = d.getCapacity();
			totalCapacityTons += capacityKg / 1000.0; // kg -> tons

			// Use the usage record for the date if available, else current fill level
			DumpsterUsageRecord match = d.getUsageHistory().stream()
					.filter(r -> r.getDate().equals(date))
					.findFirst().orElse(null);

			FillLevel fillLevel = (match != null) ? match.getFillLevel() : d.getFillLevel();
			
			// Calculate occupied weight based on fill level percentage
			double fillPercentage = getFillLevelPercentage(fillLevel);
			double occupiedKg = capacityKg * fillPercentage;
			occupiedTons += occupiedKg / 1000.0;
		}

		return Math.max(0.0, totalCapacityTons - occupiedTons);
	}

	/**
	 * Helper method to convert FillLevel enum to percentage
	 */
	private double getFillLevelPercentage(FillLevel fillLevel) {
		switch (fillLevel) {
			case GREEN:
				return 0.33; // 0-33% full
			case ORANGE:
				return 0.66; // 33-66% full
			case RED:
				return 0.90; // 66-100% full (assume 90% average)
			default:
				return 0.0;
		}
	}

	/**
	 * Assigns a single dumpster to a recycling plant for a specific date
	 */
	public Assignment assignDumpsterToPlant(LocalDate date, Long dumpsterId, Long employeeId, Long plantId) {
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Dumpster ID cannot be null");
		}
		if (employeeId == null) {
			throw new IllegalArgumentException("Employee ID cannot be null");
		}
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		Optional<Employee> employee = employeeRepository.findById(employeeId);
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);

		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found: " + dumpsterId);
		}
		if (employee.isEmpty()) {
			throw new RuntimeException("Employee not found: " + employeeId);
		}
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found: " + plantId);
		}

		// Check if this dumpster is already assigned on this date
		boolean alreadyAssigned = assignmentRepository.findAll().stream()
				.anyMatch(a -> a.getDumpster().getId().equals(dumpsterId) && a.getDate().equals(date));

		if (alreadyAssigned) {
			throw new IllegalArgumentException("Dumpster " + dumpsterId + " is already assigned for date " + date);
		}

		Assignment assignment = new Assignment(date, dumpster.get(), employee.get(), plant.get());
		// ID will be auto-generated by JPA
		return assignmentRepository.save(assignment);
	}

	/**
	 * Gets all assignments for a specific date
	 */
	public List<Assignment> getAssignmentsByDate(LocalDate date) {
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		return assignmentRepository.findAll().stream()
				.filter(a -> a.getDate().equals(date))
				.collect(Collectors.toList());
	}

	/**
	 * Gets all assignments for a specific plant
	 */
	public List<Assignment> getAssignmentsByPlant(Long plantId) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		return assignmentRepository.findAll().stream()
				.filter(a -> a.getPlant() != null && a.getPlant().getId().equals(plantId))
				.collect(Collectors.toList());
	}
}