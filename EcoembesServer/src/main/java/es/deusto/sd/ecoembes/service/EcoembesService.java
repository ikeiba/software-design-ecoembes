/**
 * This code is based on solutions provided by ChatGPT 4o and 
 * adapted using GitHub Copilot. It has been thoroughly reviewed 
 * and validated to ensure correctness and that it is free of errors.
 */
package es.deusto.sd.ecoembes.service;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import es.deusto.sd.ecoembes.dao.AssignmentRepository;
import es.deusto.sd.ecoembes.dao.DumpsterRepository;
import es.deusto.sd.ecoembes.dao.DumpsterUsageRecordRepository;
import es.deusto.sd.ecoembes.dao.EmployeeRepository;
import es.deusto.sd.ecoembes.dao.RecyclingPlantRepository;
import es.deusto.sd.ecoembes.dto.AssignmentExternalNotificationDTO;
import es.deusto.sd.ecoembes.entity.Assignment;
import es.deusto.sd.ecoembes.entity.Dumpster;
import es.deusto.sd.ecoembes.entity.DumpsterUsageRecord;
import es.deusto.sd.ecoembes.entity.Employee;
import es.deusto.sd.ecoembes.entity.FillLevel;
import es.deusto.sd.ecoembes.entity.RecyclingPlant;
import es.deusto.sd.ecoembes.external.IServiceGateway;
import es.deusto.sd.ecoembes.factory.ServiceGatewayFactory;

@Service
public class EcoembesService {

	private final DumpsterRepository dumpsterRepository;
	private final RecyclingPlantRepository plantRepository;
	private final EmployeeRepository employeeRepository;
	private final AssignmentRepository assignmentRepository;
	private final DumpsterUsageRecordRepository usageRecordRepository; // No se usa ahora mismo, pero podria ser util luego
    private final ServiceGatewayFactory gatewayFactory; 

	public EcoembesService(DumpsterRepository dumpsterRepository,
						   RecyclingPlantRepository plantRepository,
						   EmployeeRepository employeeRepository,
						   AssignmentRepository assignmentRepository,
						   DumpsterUsageRecordRepository usageRecordRepository,
						   ServiceGatewayFactory gatewayFactory) {
		this.dumpsterRepository = dumpsterRepository;
		this.plantRepository = plantRepository;
		this.employeeRepository = employeeRepository;
		this.assignmentRepository = assignmentRepository;
		this.usageRecordRepository = usageRecordRepository;
		this.gatewayFactory = gatewayFactory;
	}

	// -------------------------- Service methods (work only with entities) --------------------------

	/**
	 * Updates the status of a dumpster with sensor data
	 */
	public void updateDumpsterInfo(Long dumpsterId, int estimatedContainers, FillLevel fillLevel) {
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Dumpster ID cannot be null");
		}
		if (estimatedContainers < 0) {
			throw new IllegalArgumentException("Estimated containers cannot be negative");
		}
		if (fillLevel == null) {
			throw new IllegalArgumentException("Fill level cannot be null");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found");
		}

		dumpster.get().updateStatus(estimatedContainers, fillLevel);
		dumpsterRepository.save(dumpster.get());
	}

	/**
	 * Creates a new dumpster
	 */
	public Dumpster createDumpster(String location, String postalCode, double initialCapacity) {
		if (location == null || location.isBlank()) {
			throw new IllegalArgumentException("Location cannot be null or empty");
		}
		if (postalCode == null || postalCode.isBlank()) {
			throw new IllegalArgumentException("Postal code cannot be null or empty");
		}
		if (initialCapacity <= 0) {
			throw new IllegalArgumentException("Initial capacity must be greater than zero");
		}

		Dumpster d = new Dumpster(location, postalCode, initialCapacity);
		// ID will be auto-generated by JPA
		return dumpsterRepository.save(d);
	}

	/**
	 * Gets usage history for a dumpster within a date range
	 */
	public List<DumpsterUsageRecord> getDumpsterUsage(Long dumpsterId, LocalDate startDate, LocalDate endDate) {
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Invalid dumpster ID");
		}
		if (startDate == null || endDate == null) {
			throw new IllegalArgumentException("Start date and end date cannot be null");
		}
		if (startDate.isAfter(endDate)) {
			throw new IllegalArgumentException("Start date must be before or equal to end date");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found");
		}

		return dumpster.get().getUsageHistory().stream()
				.filter(r -> !(r.getDate().isBefore(startDate) || r.getDate().isAfter(endDate)))
				.collect(Collectors.toList());
	}

	/**
	 * Gets all dumpsters in a specific postal code area with their status on a given date
	 */
	public List<Dumpster> getDumpstersByArea(String postalCode) {
		if (postalCode == null || postalCode.isBlank()) {
			throw new IllegalArgumentException("Postal code cannot be null or empty");
		}

		return dumpsterRepository.findByPostalCode(postalCode);
	}

	/**
	 * Gets the fill level for a dumpster on a specific date
	 */
	public FillLevel getDumpsterFillLevelOnDate(Dumpster dumpster, LocalDate date) {
		if (dumpster == null) {
			throw new IllegalArgumentException("Dumpster cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}

		DumpsterUsageRecord match = dumpster.getUsageHistory().stream()
				.filter(r -> r.getDate().equals(date))
				.findFirst().orElse(null);

		return (match != null) ? match.getFillLevel() : dumpster.getFillLevel();
	}

	/**
	 * Gets all recycling plants
	 */
	public List<RecyclingPlant> getAllPlants() {
		return plantRepository.findAll();
	}

	/**
	 * Gets a single recycling plant by ID
	 */
	public RecyclingPlant getPlantById(Long plantId) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}
		return plant.get();
	}

	/**
	 * Gets all dumpsters assigned to a plant on a specific date
	 */
	public List<Dumpster> getAssignedDumpsters(Long plantId, LocalDate date) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}

		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}

		// Use efficient repository query instead of loading all assignments
		return assignmentRepository.findByPlantAndDate(plant.get(), date).stream()
				.map(Assignment::getDumpster)
				.filter(d -> d != null)
				.collect(Collectors.toList());
	}

	/**
	 * Calculates available capacity for a plant on a given date
	 */
	public double calculatePlantCapacity(Long plantId, LocalDate date) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found");
		}

		IServiceGateway gateway = gatewayFactory.getGateway(plant.get().getName());
		double capacity = gateway.getCapacity(date);


		return capacity;
	}



	/**
	 * Assigns a single dumpster to a recycling plant for a specific date
	 */
	public Assignment assignDumpsterToPlant(LocalDate date, Long dumpsterId, Long employeeId, Long plantId) {
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		if (dumpsterId == null) {
			throw new IllegalArgumentException("Dumpster ID cannot be null");
		}
		if (employeeId == null) {
			throw new IllegalArgumentException("Employee ID cannot be null");
		}
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}

		Optional<Dumpster> dumpster = dumpsterRepository.findById(dumpsterId);
		Optional<Employee> employee = employeeRepository.findById(employeeId);
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);



		if (dumpster.isEmpty()) {
			throw new RuntimeException("Dumpster not found: " + dumpsterId);
		}
		if (employee.isEmpty()) {
			throw new RuntimeException("Employee not found: " + employeeId);
		}
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found: " + plantId);
		}

		// Check if this dumpster is already assigned on this date using efficient query
		List<Assignment> existingAssignments = assignmentRepository.findByDumpsterAndDate(dumpster.get(), date);
		if (!existingAssignments.isEmpty()) {
			throw new IllegalArgumentException("Dumpster " + dumpsterId + " is already assigned for date " + date);
		}

		IServiceGateway gateway = gatewayFactory.getGateway(plant.get().getName());
		AssignmentExternalNotificationDTO assignExternalDto = new AssignmentExternalNotificationDTO(date, 1, dumpster.get().getEstimatedContainers()); 
		
		AssignmentExternalNotificationDTO assignmentExternalNotificationDTO;
		try {
			assignmentExternalNotificationDTO = gateway.assignDumpsterToPlant(assignExternalDto);
		} catch (Exception e) {
			throw new RuntimeException("Error: " + e.getMessage(), e);
		}
		Assignment assignment = new Assignment(assignmentExternalNotificationDTO.getDate(), dumpster.get(), employee.get(), plant.get());
		// ID will be auto-generated by JPA

		return assignmentRepository.save(assignment);
	}

	/**
	 * Gets all assignments for a specific date
	 */
	public List<Assignment> getAssignmentsByDate(LocalDate date) {
		if (date == null) {
			throw new IllegalArgumentException("Date cannot be null");
		}
		// Use efficient repository query method
		return assignmentRepository.findByDate(date);
	}

	/**
	 * Gets all assignments for a specific plant
	 */
	public List<Assignment> getAssignmentsByPlant(Long plantId) {
		if (plantId == null) {
			throw new IllegalArgumentException("Plant ID cannot be null");
		}
		Optional<RecyclingPlant> plant = plantRepository.findById(plantId);
		if (plant.isEmpty()) {
			throw new RuntimeException("Plant not found: " + plantId);
		}
		// Use efficient repository query method
		return assignmentRepository.findByPlant(plant.get());
	}
}